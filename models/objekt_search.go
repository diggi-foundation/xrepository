// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ObjektSearch objekt search
//
// swagger:model ObjektSearch
type ObjektSearch struct {

	// daten sprachen
	DatenSprachen []string `json:"datenSprachen"`

	// eigentuemer
	Eigentuemer int64 `json:"eigentuemer,omitempty"`

	// herausgebername kurz
	HerausgebernameKurz []string `json:"herausgebernameKurz"`

	// kennungen
	Kennungen []string `json:"kennungen"`

	// limit
	Limit int32 `json:"limit,omitempty"`

	// match
	Match string `json:"match,omitempty"`

	// metadaten sprachen
	MetadatenSprachen []string `json:"metadatenSprachen"`

	// mime type
	MimeType string `json:"mimeType,omitempty"`

	// name technisch
	NameTechnisch string `json:"nameTechnisch,omitempty"`

	// offset
	Offset int32 `json:"offset,omitempty"`

	// status fassung
	StatusFassung []string `json:"statusFassung"`

	// status veroeffentlichung
	StatusVeroeffentlichung []string `json:"statusVeroeffentlichung"`

	// status verwendung
	StatusVerwendung []string `json:"statusVerwendung"`

	// status zertifizierung
	StatusZertifizierung []string `json:"statusZertifizierung"`

	// typen
	Typen []string `json:"typen"`

	// vorentwuerfe
	Vorentwuerfe bool `json:"vorentwuerfe,omitempty"`

	// xrepository2 kennung
	Xrepository2Kennung string `json:"xrepository2Kennung,omitempty"`
}

// Validate validates this objekt search
func (m *ObjektSearch) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStatusFassung(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatusVeroeffentlichung(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatusVerwendung(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatusZertifizierung(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTypen(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var objektSearchStatusFassungItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ENDFASSUNG","ENTWURF"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		objektSearchStatusFassungItemsEnum = append(objektSearchStatusFassungItemsEnum, v)
	}
}

func (m *ObjektSearch) validateStatusFassungItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, objektSearchStatusFassungItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ObjektSearch) validateStatusFassung(formats strfmt.Registry) error {
	if swag.IsZero(m.StatusFassung) { // not required
		return nil
	}

	for i := 0; i < len(m.StatusFassung); i++ {

		// value enum
		if err := m.validateStatusFassungItemsEnum("statusFassung"+"."+strconv.Itoa(i), "body", m.StatusFassung[i]); err != nil {
			return err
		}

	}

	return nil
}

var objektSearchStatusVeroeffentlichungItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NICHT_VEROEFFENTLICHT","VEROEFFENTLICHT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		objektSearchStatusVeroeffentlichungItemsEnum = append(objektSearchStatusVeroeffentlichungItemsEnum, v)
	}
}

func (m *ObjektSearch) validateStatusVeroeffentlichungItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, objektSearchStatusVeroeffentlichungItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ObjektSearch) validateStatusVeroeffentlichung(formats strfmt.Registry) error {
	if swag.IsZero(m.StatusVeroeffentlichung) { // not required
		return nil
	}

	for i := 0; i < len(m.StatusVeroeffentlichung); i++ {

		// value enum
		if err := m.validateStatusVeroeffentlichungItemsEnum("statusVeroeffentlichung"+"."+strconv.Itoa(i), "body", m.StatusVeroeffentlichung[i]); err != nil {
			return err
		}

	}

	return nil
}

var objektSearchStatusVerwendungItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["AKTUELL","AUSGESONDERT","VERALTET","ZUR_AUSSONDERUNG"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		objektSearchStatusVerwendungItemsEnum = append(objektSearchStatusVerwendungItemsEnum, v)
	}
}

func (m *ObjektSearch) validateStatusVerwendungItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, objektSearchStatusVerwendungItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ObjektSearch) validateStatusVerwendung(formats strfmt.Registry) error {
	if swag.IsZero(m.StatusVerwendung) { // not required
		return nil
	}

	for i := 0; i < len(m.StatusVerwendung); i++ {

		// value enum
		if err := m.validateStatusVerwendungItemsEnum("statusVerwendung"+"."+strconv.Itoa(i), "body", m.StatusVerwendung[i]); err != nil {
			return err
		}

	}

	return nil
}

var objektSearchStatusZertifizierungItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NICHT_ZERTIFIZIERT","ZERTIFIZIERT","ZERTIFIZIERUNG_BEANTRAGT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		objektSearchStatusZertifizierungItemsEnum = append(objektSearchStatusZertifizierungItemsEnum, v)
	}
}

func (m *ObjektSearch) validateStatusZertifizierungItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, objektSearchStatusZertifizierungItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ObjektSearch) validateStatusZertifizierung(formats strfmt.Registry) error {
	if swag.IsZero(m.StatusZertifizierung) { // not required
		return nil
	}

	for i := 0; i < len(m.StatusZertifizierung); i++ {

		// value enum
		if err := m.validateStatusZertifizierungItemsEnum("statusZertifizierung"+"."+strconv.Itoa(i), "body", m.StatusZertifizierung[i]); err != nil {
			return err
		}

	}

	return nil
}

var objektSearchTypenItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["STANDARD","DATEI","CODELISTE","VERSION_CODELISTE","VERSION_STANDARD","KERNKOMPONENTE","VERSION_KERNKOMPONENTE","NUTZER","SEITE","MAIL_TEMPLATE","BILD","REDAKTIONELLE_LISTE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		objektSearchTypenItemsEnum = append(objektSearchTypenItemsEnum, v)
	}
}

func (m *ObjektSearch) validateTypenItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, objektSearchTypenItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ObjektSearch) validateTypen(formats strfmt.Registry) error {
	if swag.IsZero(m.Typen) { // not required
		return nil
	}

	for i := 0; i < len(m.Typen); i++ {

		// value enum
		if err := m.validateTypenItemsEnum("typen"+"."+strconv.Itoa(i), "body", m.Typen[i]); err != nil {
			return err
		}

	}

	return nil
}

// ContextValidate validates this objekt search based on context it is used
func (m *ObjektSearch) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ObjektSearch) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ObjektSearch) UnmarshalBinary(b []byte) error {
	var res ObjektSearch
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
