// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Metadaten metadaten
//
// swagger:model Metadaten
type Metadaten struct {

	// aenderung zur vorversion
	AenderungZurVorversion []*StringMehrsprachig `json:"aenderungZurVorversion"`

	// beschreibung
	Beschreibung []*StringMehrsprachig `json:"beschreibung"`

	// bezugsorte
	Bezugsorte []string `json:"bezugsorte"`

	// gueltig ab
	// Format: date-time
	GueltigAb strfmt.DateTime `json:"gueltigAb,omitempty"`

	// handbuch version
	HandbuchVersion string `json:"handbuchVersion,omitempty"`

	// herausgebername kurz
	HerausgebernameKurz []*StringLatinMehrsprachig `json:"herausgebernameKurz"`

	// herausgebername lang
	HerausgebernameLang []*StringLatinMehrsprachig `json:"herausgebernameLang"`

	// kennung
	Kennung string `json:"kennung,omitempty"`

	// kennung inhalt
	KennungInhalt string `json:"kennungInhalt,omitempty"`

	// name kurz
	NameKurz []*StringLatinMehrsprachig `json:"nameKurz"`

	// name lang
	NameLang []*StringLatinMehrsprachig `json:"nameLang"`

	// name technisch
	NameTechnisch string `json:"nameTechnisch,omitempty"`

	// version
	Version string `json:"version,omitempty"`

	// version beschreibung
	VersionBeschreibung []*StringMehrsprachig `json:"versionBeschreibung"`

	// xoev handbuch
	XoevHandbuch bool `json:"xoevHandbuch,omitempty"`
}

// Validate validates this metadaten
func (m *Metadaten) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAenderungZurVorversion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBeschreibung(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGueltigAb(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHerausgebernameKurz(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHerausgebernameLang(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNameKurz(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNameLang(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersionBeschreibung(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Metadaten) validateAenderungZurVorversion(formats strfmt.Registry) error {
	if swag.IsZero(m.AenderungZurVorversion) { // not required
		return nil
	}

	for i := 0; i < len(m.AenderungZurVorversion); i++ {
		if swag.IsZero(m.AenderungZurVorversion[i]) { // not required
			continue
		}

		if m.AenderungZurVorversion[i] != nil {
			if err := m.AenderungZurVorversion[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aenderungZurVorversion" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("aenderungZurVorversion" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Metadaten) validateBeschreibung(formats strfmt.Registry) error {
	if swag.IsZero(m.Beschreibung) { // not required
		return nil
	}

	for i := 0; i < len(m.Beschreibung); i++ {
		if swag.IsZero(m.Beschreibung[i]) { // not required
			continue
		}

		if m.Beschreibung[i] != nil {
			if err := m.Beschreibung[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("beschreibung" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("beschreibung" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Metadaten) validateGueltigAb(formats strfmt.Registry) error {
	if swag.IsZero(m.GueltigAb) { // not required
		return nil
	}

	if err := validate.FormatOf("gueltigAb", "body", "date-time", m.GueltigAb.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Metadaten) validateHerausgebernameKurz(formats strfmt.Registry) error {
	if swag.IsZero(m.HerausgebernameKurz) { // not required
		return nil
	}

	for i := 0; i < len(m.HerausgebernameKurz); i++ {
		if swag.IsZero(m.HerausgebernameKurz[i]) { // not required
			continue
		}

		if m.HerausgebernameKurz[i] != nil {
			if err := m.HerausgebernameKurz[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("herausgebernameKurz" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("herausgebernameKurz" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Metadaten) validateHerausgebernameLang(formats strfmt.Registry) error {
	if swag.IsZero(m.HerausgebernameLang) { // not required
		return nil
	}

	for i := 0; i < len(m.HerausgebernameLang); i++ {
		if swag.IsZero(m.HerausgebernameLang[i]) { // not required
			continue
		}

		if m.HerausgebernameLang[i] != nil {
			if err := m.HerausgebernameLang[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("herausgebernameLang" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("herausgebernameLang" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Metadaten) validateNameKurz(formats strfmt.Registry) error {
	if swag.IsZero(m.NameKurz) { // not required
		return nil
	}

	for i := 0; i < len(m.NameKurz); i++ {
		if swag.IsZero(m.NameKurz[i]) { // not required
			continue
		}

		if m.NameKurz[i] != nil {
			if err := m.NameKurz[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nameKurz" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nameKurz" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Metadaten) validateNameLang(formats strfmt.Registry) error {
	if swag.IsZero(m.NameLang) { // not required
		return nil
	}

	for i := 0; i < len(m.NameLang); i++ {
		if swag.IsZero(m.NameLang[i]) { // not required
			continue
		}

		if m.NameLang[i] != nil {
			if err := m.NameLang[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nameLang" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nameLang" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Metadaten) validateVersionBeschreibung(formats strfmt.Registry) error {
	if swag.IsZero(m.VersionBeschreibung) { // not required
		return nil
	}

	for i := 0; i < len(m.VersionBeschreibung); i++ {
		if swag.IsZero(m.VersionBeschreibung[i]) { // not required
			continue
		}

		if m.VersionBeschreibung[i] != nil {
			if err := m.VersionBeschreibung[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("versionBeschreibung" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("versionBeschreibung" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this metadaten based on the context it is used
func (m *Metadaten) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAenderungZurVorversion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBeschreibung(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHerausgebernameKurz(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHerausgebernameLang(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNameKurz(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNameLang(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersionBeschreibung(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Metadaten) contextValidateAenderungZurVorversion(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AenderungZurVorversion); i++ {

		if m.AenderungZurVorversion[i] != nil {

			if swag.IsZero(m.AenderungZurVorversion[i]) { // not required
				return nil
			}

			if err := m.AenderungZurVorversion[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aenderungZurVorversion" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("aenderungZurVorversion" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Metadaten) contextValidateBeschreibung(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Beschreibung); i++ {

		if m.Beschreibung[i] != nil {

			if swag.IsZero(m.Beschreibung[i]) { // not required
				return nil
			}

			if err := m.Beschreibung[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("beschreibung" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("beschreibung" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Metadaten) contextValidateHerausgebernameKurz(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.HerausgebernameKurz); i++ {

		if m.HerausgebernameKurz[i] != nil {

			if swag.IsZero(m.HerausgebernameKurz[i]) { // not required
				return nil
			}

			if err := m.HerausgebernameKurz[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("herausgebernameKurz" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("herausgebernameKurz" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Metadaten) contextValidateHerausgebernameLang(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.HerausgebernameLang); i++ {

		if m.HerausgebernameLang[i] != nil {

			if swag.IsZero(m.HerausgebernameLang[i]) { // not required
				return nil
			}

			if err := m.HerausgebernameLang[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("herausgebernameLang" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("herausgebernameLang" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Metadaten) contextValidateNameKurz(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NameKurz); i++ {

		if m.NameKurz[i] != nil {

			if swag.IsZero(m.NameKurz[i]) { // not required
				return nil
			}

			if err := m.NameKurz[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nameKurz" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nameKurz" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Metadaten) contextValidateNameLang(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NameLang); i++ {

		if m.NameLang[i] != nil {

			if swag.IsZero(m.NameLang[i]) { // not required
				return nil
			}

			if err := m.NameLang[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nameLang" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nameLang" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Metadaten) contextValidateVersionBeschreibung(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VersionBeschreibung); i++ {

		if m.VersionBeschreibung[i] != nil {

			if swag.IsZero(m.VersionBeschreibung[i]) { // not required
				return nil
			}

			if err := m.VersionBeschreibung[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("versionBeschreibung" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("versionBeschreibung" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Metadaten) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Metadaten) UnmarshalBinary(b []byte) error {
	var res Metadaten
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
