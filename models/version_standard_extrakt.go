// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// VersionStandardExtrakt version standard extrakt
//
// swagger:model VersionStandardExtrakt
type VersionStandardExtrakt struct {

	// abie extrakt
	AbieExtrakt []*ABIEExtrakt `json:"abieExtrakt" xml:"abieExtrakt"`

	// beschreibung
	Beschreibung string `json:"beschreibung,omitempty" xml:"versionStandard.beschreibung,omitempty"`

	// framework version
	FrameworkVersion string `json:"frameworkVersion,omitempty" xml:"frameworkVersion,attr,omitempty"`

	// genutzte codeliste
	GenutzteCodeliste []*GenutzteCodeliste `json:"genutzteCodeliste" xml:"genutzteCodeliste"`

	// genutzte version codeliste
	GenutzteVersionCodeliste []*GenutzteVersionCodeliste `json:"genutzteVersionCodeliste" xml:"genutzteVersionCodeliste"`

	// genutzte version standard
	GenutzteVersionStandard []*GenutzteVersionStandard `json:"genutzteVersionStandard" xml:"genutzteVersionStandard"`

	// kennung
	Kennung string `json:"kennung,omitempty"`

	// kennung inhalt
	// Required: true
	KennungInhalt *string `json:"kennungInhalt" xml:"standard.kennung"`

	// name kurz
	// Required: true
	NameKurz *string `json:"nameKurz" xml:"standard.nameKurz"`

	// name lang
	// Required: true
	NameLang *string `json:"nameLang" xml:"standard.nameLang"`

	// name technisch
	// Required: true
	NameTechnisch *string `json:"nameTechnisch" xml:"standard.nameTechnisch"`

	// standard beschreibung
	// Required: true
	StandardBeschreibung *string `json:"standardBeschreibung" xml:"standard.beschreibung"`

	// version
	// Required: true
	Version *string `json:"version" xml:"versionStandard.version"`

	// version standard genutzte version datentyp kennung
	VersionStandardGenutzteVersionDatentypKennung []string `json:"versionStandardGenutzteVersionDatentypKennung" xml:"versionStandard.genutzteVersionDatentyp.kennung"`

	// version standard name modellierungswerkzeug
	VersionStandardNameModellierungswerkzeug string `json:"versionStandardNameModellierungswerkzeug,omitempty" xml:"versionStandard.nameModellierungswerkzeug,omitempty"`

	// version standard version modellierungswerkzeug
	VersionStandardVersionModellierungswerkzeug string `json:"versionStandardVersionModellierungswerkzeug,omitempty" xml:"versionStandard.versionModellierungswerkzeug,omitempty"`

	// version standard version x generator
	VersionStandardVersionXGenerator string `json:"versionStandardVersionXGenerator,omitempty" xml:"versionStandard.versionXGenerator,omitempty"`

	// version standard version x o e v handbuch
	// Required: true
	VersionStandardVersionXOEVHandbuch *string `json:"versionStandardVersionXOEVHandbuch" xml:"versionStandard.versionXOEVHandbuch"`

	// version standard version x o e v profil
	VersionStandardVersionXOEVProfil string `json:"versionStandardVersionXOEVProfil,omitempty" xml:"versionStandard.versionXOEVProfil,omitempty"`

	// xmlschema
	Xmlschema *XmlschemaExtrakt `json:"xmlschema,omitempty" xml:"xmlschema,omitempty"`
}

// Validate validates this version standard extrakt
func (m *VersionStandardExtrakt) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAbieExtrakt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGenutzteCodeliste(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGenutzteVersionCodeliste(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGenutzteVersionStandard(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKennungInhalt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNameKurz(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNameLang(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNameTechnisch(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStandardBeschreibung(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersionStandardVersionXOEVHandbuch(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateXmlschema(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VersionStandardExtrakt) validateAbieExtrakt(formats strfmt.Registry) error {
	if swag.IsZero(m.AbieExtrakt) { // not required
		return nil
	}

	for i := 0; i < len(m.AbieExtrakt); i++ {
		if swag.IsZero(m.AbieExtrakt[i]) { // not required
			continue
		}

		if m.AbieExtrakt[i] != nil {
			if err := m.AbieExtrakt[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("abieExtrakt" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("abieExtrakt" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VersionStandardExtrakt) validateGenutzteCodeliste(formats strfmt.Registry) error {
	if swag.IsZero(m.GenutzteCodeliste) { // not required
		return nil
	}

	for i := 0; i < len(m.GenutzteCodeliste); i++ {
		if swag.IsZero(m.GenutzteCodeliste[i]) { // not required
			continue
		}

		if m.GenutzteCodeliste[i] != nil {
			if err := m.GenutzteCodeliste[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("genutzteCodeliste" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("genutzteCodeliste" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VersionStandardExtrakt) validateGenutzteVersionCodeliste(formats strfmt.Registry) error {
	if swag.IsZero(m.GenutzteVersionCodeliste) { // not required
		return nil
	}

	for i := 0; i < len(m.GenutzteVersionCodeliste); i++ {
		if swag.IsZero(m.GenutzteVersionCodeliste[i]) { // not required
			continue
		}

		if m.GenutzteVersionCodeliste[i] != nil {
			if err := m.GenutzteVersionCodeliste[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("genutzteVersionCodeliste" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("genutzteVersionCodeliste" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VersionStandardExtrakt) validateGenutzteVersionStandard(formats strfmt.Registry) error {
	if swag.IsZero(m.GenutzteVersionStandard) { // not required
		return nil
	}

	for i := 0; i < len(m.GenutzteVersionStandard); i++ {
		if swag.IsZero(m.GenutzteVersionStandard[i]) { // not required
			continue
		}

		if m.GenutzteVersionStandard[i] != nil {
			if err := m.GenutzteVersionStandard[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("genutzteVersionStandard" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("genutzteVersionStandard" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VersionStandardExtrakt) validateKennungInhalt(formats strfmt.Registry) error {

	if err := validate.Required("kennungInhalt", "body", m.KennungInhalt); err != nil {
		return err
	}

	return nil
}

func (m *VersionStandardExtrakt) validateNameKurz(formats strfmt.Registry) error {

	if err := validate.Required("nameKurz", "body", m.NameKurz); err != nil {
		return err
	}

	return nil
}

func (m *VersionStandardExtrakt) validateNameLang(formats strfmt.Registry) error {

	if err := validate.Required("nameLang", "body", m.NameLang); err != nil {
		return err
	}

	return nil
}

func (m *VersionStandardExtrakt) validateNameTechnisch(formats strfmt.Registry) error {

	if err := validate.Required("nameTechnisch", "body", m.NameTechnisch); err != nil {
		return err
	}

	return nil
}

func (m *VersionStandardExtrakt) validateStandardBeschreibung(formats strfmt.Registry) error {

	if err := validate.Required("standardBeschreibung", "body", m.StandardBeschreibung); err != nil {
		return err
	}

	return nil
}

func (m *VersionStandardExtrakt) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *VersionStandardExtrakt) validateVersionStandardVersionXOEVHandbuch(formats strfmt.Registry) error {

	if err := validate.Required("versionStandardVersionXOEVHandbuch", "body", m.VersionStandardVersionXOEVHandbuch); err != nil {
		return err
	}

	return nil
}

func (m *VersionStandardExtrakt) validateXmlschema(formats strfmt.Registry) error {
	if swag.IsZero(m.Xmlschema) { // not required
		return nil
	}

	if m.Xmlschema != nil {
		if err := m.Xmlschema.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("xmlschema")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("xmlschema")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this version standard extrakt based on the context it is used
func (m *VersionStandardExtrakt) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAbieExtrakt(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGenutzteCodeliste(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGenutzteVersionCodeliste(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGenutzteVersionStandard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateXmlschema(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VersionStandardExtrakt) contextValidateAbieExtrakt(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AbieExtrakt); i++ {

		if m.AbieExtrakt[i] != nil {

			if swag.IsZero(m.AbieExtrakt[i]) { // not required
				return nil
			}

			if err := m.AbieExtrakt[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("abieExtrakt" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("abieExtrakt" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VersionStandardExtrakt) contextValidateGenutzteCodeliste(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.GenutzteCodeliste); i++ {

		if m.GenutzteCodeliste[i] != nil {

			if swag.IsZero(m.GenutzteCodeliste[i]) { // not required
				return nil
			}

			if err := m.GenutzteCodeliste[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("genutzteCodeliste" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("genutzteCodeliste" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VersionStandardExtrakt) contextValidateGenutzteVersionCodeliste(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.GenutzteVersionCodeliste); i++ {

		if m.GenutzteVersionCodeliste[i] != nil {

			if swag.IsZero(m.GenutzteVersionCodeliste[i]) { // not required
				return nil
			}

			if err := m.GenutzteVersionCodeliste[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("genutzteVersionCodeliste" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("genutzteVersionCodeliste" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VersionStandardExtrakt) contextValidateGenutzteVersionStandard(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.GenutzteVersionStandard); i++ {

		if m.GenutzteVersionStandard[i] != nil {

			if swag.IsZero(m.GenutzteVersionStandard[i]) { // not required
				return nil
			}

			if err := m.GenutzteVersionStandard[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("genutzteVersionStandard" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("genutzteVersionStandard" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VersionStandardExtrakt) contextValidateXmlschema(ctx context.Context, formats strfmt.Registry) error {

	if m.Xmlschema != nil {

		if swag.IsZero(m.Xmlschema) { // not required
			return nil
		}

		if err := m.Xmlschema.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("xmlschema")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("xmlschema")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VersionStandardExtrakt) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VersionStandardExtrakt) UnmarshalBinary(b []byte) error {
	var res VersionStandardExtrakt
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
